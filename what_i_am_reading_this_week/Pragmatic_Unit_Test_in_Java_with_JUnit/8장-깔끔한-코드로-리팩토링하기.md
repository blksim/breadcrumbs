단위 테스트를 만들면 낮은 중복성과 명확성이라는 두 마리 토끼를 한 번에 잡을 수 있다!

### 8.1 작은 리팩토링
리팩토링을 할 때 무작정 코드를 뒤집을 수는 없으므로, 적절한 보호 장치가 되어 주는 것이 테스트 코드다.

matches()를 보자. 딱 봐도 많은 로직이 들어가 있다. 조건문이 잘 읽히지 않는다.
```
public boolean matches(Criteria criteria) {
  score = 0;
  
  boolean kill = false;
  boolean anyMatches = false;
  for (Criterion criterion: criteria) {
    Answer answer = answers.get(
      criterion.getAnswer().getQuestionText());
      // match 할당 부분을 단순하게 바꿔보자.
      boolean match = criterion.getWeight() == Weight.DontCare || answer.match(criterion.getAnswer());
      
    if (!match && criterion.getWeight() == Weight.MustMatch) {
      kill = true;
    }
    if (match) {
      score += criterion.getWeight().getValue();
    }
    anyMatches |= match;
  }
  if (kill)
    return false;
  return anyMatches;
}
```

```
public boolean matches(Criteria criteria) {
  score = 0;
  
  boolean kill = false;
  boolean anyMatches = false;
  for (Criterion criterion: criteria) {
    Answer answer = answers.get(
      criterion.getAnswer().getQuestionText());
    boolean match = matches(criterion, answer);
    
    if (!match && criterion.getWeight() == Weight.MustMatch) {
      kill = true;
    }
    if (match) {
      score += criterion.getWeight().getValue();
    }
    anyMatches |= match;
  }
  if (kill)
      return false;
  return anyMatches;
}

private boolean matches(Criterion criterion, Answer answer) {
  return criterion.getWeight() == Weight.DontCare || answer.match(criterion.getAnswer());
}
```
할당 부분을 별도 메서드로 추출함으로써 복잡성을 감소시킨다.
> 코드를 안전하게 옮길 수 있는 능력은 단위 테스트의 가장 중요한 이점입니다...... 충분한 테스트가 없으면 코드를 변경하기 어렵습니다. 혹은 이러한 변경은 매우 높은 리스크가 발생합니다.
