### 14.1 HTTP를 안전하게 만들기
**HTTPS**
- HTTPS는 HTTP 트랜잭션을 안전하게 만드는 가장 인기있는 방식
- URL이 https://로 시작
- HTTPS 사용 시, 모든 요청과 응답 데이터는 네트워크를 타기 전 암호화된다
- HTTPS는 HTTP와 달리 하부에 보안 계층이 추가되어, 인코딩 디코딩은 여기에서 이루어진다.
- 네트워크 인터페이스(데이터링크 계층) --> IP(네트워크 계층) --> TCP(전송 계층) --> **SSL 혹은 TLS(보안 계층)** --> HTTP(애플리케이션 계층)

### 14.3 대칭키 암호법
- 대칭키 암호 알고리즘은 인코딩할 때와 디코딩할 때 사용하는 키가 같다.
- 그러므로 인코딩과 디코딩에 사용할 키는 암호화되어 공유되어야 한다.
> 발송자는 공유된 비밀 키를, 메시지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해 사용한다. 수신자는 역시 암호문을 받은 뒤 같은 공유된 키를 사용하여 원래의 평문을 복원하기 위해 해독 함수를 적용한다.<br>
> 잘 알려진 대칭키 암호 알고리즘으로는 DES, Triple-DES, RC2, RC4 등이 있다.(p362)

- 결국 비밀 키가 무엇인지 알아내면 된다.
- 좋은 암호 알고리즘은 무차별 대입 공격밖에는 답이 없는 알고리즘인데, 당연히 이 공격은 비용을 많이 들일 수록 키를 알아내는 데 걸리는 기간이 짧아진다.
- 하지만 아무리 비용을 들여도 실질적으로 깨트릴 수 없는 키는 128비트 키다. 키를 알아내려면 우주의 나이(13.8억년)보다 오래 걸린다.
- 대칭키 암호의 단점은 통신을 위해 키를 공유하고 있어야 한다는 것이다. 만약 A와 B와 C가 모두 J와 대화하길 원한다면, J는 상대에 대한 비밀키를 각각 발급해야 한다. 관리하는 입장에서 번거롭다.

### 14.4 공개키 암호법
- 대칭키 암호법과 달리, 두 개의 비대칭 키를 사용한다. 하나는 호스트의 메시지를 인코딩하기 위한 것이고, 하나는 호스트의 메시지를 디코딩하기 위한 것이다. 키는 모두에게 공개돼있지만, 개인 디코딩 키는 호스트만이 알고있다. 대칭키 암호법은 상대마다 키를 발급해야 하지만, 여기서는 같은 공개키 하나를 사용할 수 있다. 하지만 메시지를 디코딩할 수 있는 능력은 호스트에게만 부여된다.
> 그러나 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다. 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.<br>
> 예를 들어, 노드들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.(p367)

### 15.5 디지털 서명
- 디지털 서명은 누가 메시지를 썼는지, 메시지가 위조되지는 않았는지 증명하기 위해 메시지에 서명하는 기법이다.
- 서명은 암호 체크섬이며 저자만 갖고 있고, 계산할 수 있다.
- 체크섬은 개인 비밀키에 관련된 것이므로, 체크섬이 맞지 않는 위조 메시지를 가려내는 효과가 있다.
- 디지털 서명은 보통 비대칭 공개키에 의해 생성되며, 오직 소유자만 알고 있다.
- 서명 과정은 다음과 같다(p367)
> 1) 노드 A는 가변 길이 메시지를 고정 길이 요약(digest)로 만든다.<br>
> 2) 노드 A는 그 요약에, 사용자의 개인 키를 매개변수로 하는 '서명' 함수를 적용한다.<br>
> 3) 한 번 서명이 계산되면, 노드 A는 그것을 메시지의 끝에 덧붙이고 메시지와 그에 대한 서명 둘 다를 노드 B에게 전송한다.<br>
> 4) 메시지를 받은 노드 B가, 만약 그 메시지를 쓴 것이 정말로 노드 A이며 동시에 위조되지도 않았다는 것을 확인하길 원한다면, 노드 B는 서명을 검사할 수 있다. 공개키를 이용한 역함수를 사용하는데, 풀어낸 요약이 만약 노드 B가 갖고 있는 버전의 요약과 불일치하면, 메시지가 송신 중에 위조되었거나 아니면 발송자가 노드 A의 개인키를 갖고 있지 않은 것이다.(따라서 메시지를 쓴 것은 노드 A가 아니다.)

